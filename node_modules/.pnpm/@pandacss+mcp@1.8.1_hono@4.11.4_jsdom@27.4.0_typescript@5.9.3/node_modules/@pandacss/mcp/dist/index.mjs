// src/server.ts
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import { logger } from "@pandacss/logger";
import { analyze, loadConfigAndCreateContext } from "@pandacss/node";
import { TOKEN_CATEGORIES } from "@pandacss/token-dictionary";
import { resolve } from "path";
import * as z from "zod/v4";
var tokenCategorySchema = z.enum(TOKEN_CATEGORIES).optional().describe("Filter by token category");
var json = (data) => ({
  content: [{ type: "text", text: JSON.stringify(data) }]
});
function createMcpServer(options) {
  const { ctx } = options;
  const server = new McpServer({
    name: "@pandacss/mcp",
    version: "1.0.0"
  });
  const recipeNames = ctx.recipes.keys;
  const patternNames = ctx.patterns.keys;
  const recipeNameSchema = recipeNames.length ? z.enum(recipeNames).optional().describe("Filter by recipe name") : z.string().optional().describe("Filter by recipe name");
  const patternNameSchema = patternNames.length ? z.enum(patternNames).optional().describe("Filter by pattern name") : z.string().optional().describe("Filter by pattern name");
  server.registerTool(
    "get_tokens",
    {
      description: "Get all design tokens with their values, CSS variables, and usage examples",
      inputSchema: { category: tokenCategorySchema }
    },
    async ({ category }) => {
      const spec = ctx.getSpecOfType("tokens");
      const data = category ? spec.data.filter((group) => group.type === category) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_semantic_tokens",
    {
      description: "Get semantic tokens with their conditional values (responsive, color modes)",
      inputSchema: { category: tokenCategorySchema }
    },
    async ({ category }) => {
      const spec = ctx.getSpecOfType("semantic-tokens");
      const data = category ? spec.data.filter((group) => group.type === category) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_recipes",
    {
      description: "Get component recipes with their variants, default values, and usage examples",
      inputSchema: { name: recipeNameSchema }
    },
    async ({ name }) => {
      const spec = ctx.getSpecOfType("recipes");
      const data = name ? spec.data.filter((item) => item.name === name) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_patterns",
    {
      description: "Get layout patterns with their properties and usage examples",
      inputSchema: { name: patternNameSchema }
    },
    async ({ name }) => {
      const spec = ctx.getSpecOfType("patterns");
      const data = name ? spec.data.filter((item) => item.name === name) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_conditions",
    { description: "Get all conditions (breakpoints, pseudo-classes, color modes) and their CSS values" },
    async () => json(ctx.getSpecOfType("conditions"))
  );
  server.registerTool(
    "get_keyframes",
    { description: "Get keyframe animations defined in the theme" },
    async () => json(ctx.getSpecOfType("keyframes"))
  );
  server.registerTool(
    "get_text_styles",
    { description: "Get text style compositions for typography" },
    async () => json(ctx.getSpecOfType("text-styles"))
  );
  server.registerTool(
    "get_layer_styles",
    { description: "Get layer style compositions for visual styling" },
    async () => json(ctx.getSpecOfType("layer-styles"))
  );
  server.registerTool(
    "get_animation_styles",
    { description: "Get animation style compositions" },
    async () => json(ctx.getSpecOfType("animation-styles"))
  );
  server.registerTool(
    "get_color_palette",
    { description: "Get the color palette with all color values" },
    async () => json(ctx.getSpecOfType("color-palette"))
  );
  server.registerTool(
    "get_config",
    { description: "Get the resolved Panda CSS configuration including paths, JSX settings, and output options" },
    async () => json(ctx.config)
  );
  server.registerTool(
    "get_usage_report",
    {
      description: "Get a usage report of design tokens and recipes across the codebase. Shows which tokens/recipes are used, unused, or missing. Useful for auditing, cleanup, and identifying dead code.",
      inputSchema: {
        scope: z.enum(["all", "token", "recipe"]).optional().describe("Analysis scope: token, recipe, or all (default)")
      }
    },
    async ({ scope }) => {
      const result = analyze(ctx);
      const includeTokens = !scope || scope === "all" || scope === "token";
      const includeRecipes = !scope || scope === "all" || scope === "recipe";
      const report = {};
      if (includeTokens && !ctx.tokens.isEmpty) {
        const tokenReport = result.getTokenReport();
        report.tokens = tokenReport.report.getSummary();
      }
      if (includeRecipes && !ctx.recipes.isEmpty()) {
        const recipeReport = result.getRecipeReport();
        report.recipes = recipeReport.report;
      }
      return json(report);
    }
  );
  return server;
}
async function startMcpServer(options = {}) {
  const { cwd = process.cwd(), config: configPath, silent = false, transport } = options;
  if (silent) {
    logger.level = "silent";
  }
  const resolvedCwd = resolve(cwd);
  const resolvedConfigPath = configPath ? resolve(configPath) : void 0;
  const ctx = await loadConfigAndCreateContext({
    cwd: resolvedCwd,
    configPath: resolvedConfigPath
  });
  const server = createMcpServer({ ctx });
  const serverTransport = transport ?? new StdioServerTransport();
  await server.connect(serverTransport);
  console.error("Panda CSS MCP server started");
  console.error(`Working directory: ${resolvedCwd}`);
  if (resolvedConfigPath) {
    console.error(`Config path: ${resolvedConfigPath}`);
  }
  return server;
}

// src/init.ts
import * as p from "@clack/prompts";
import { logger as logger2 } from "@pandacss/logger";
import { existsSync, mkdirSync, readFileSync, writeFileSync } from "fs";
import { dirname, resolve as resolve2 } from "path";

// src/clients.ts
var MCP_CLIENTS = {
  claude: {
    name: "claude",
    label: "Claude (.mcp.json)",
    configPath: ".mcp.json",
    configKey: "mcpServers"
  },
  cursor: {
    name: "cursor",
    label: "Cursor (.cursor/mcp.json)",
    configPath: ".cursor/mcp.json",
    configKey: "mcpServers"
  },
  vscode: {
    name: "vscode",
    label: "VS Code (.vscode/mcp.json)",
    configPath: ".vscode/mcp.json",
    configKey: "servers"
  },
  windsurf: {
    name: "windsurf",
    label: "Windsurf (.windsurf/mcp.json)",
    configPath: ".windsurf/mcp.json",
    configKey: "mcpServers"
  },
  codex: {
    name: "codex",
    label: "Codex (.codex/mcp.json)",
    configPath: ".codex/mcp.json",
    configKey: "mcpServers"
  }
};
var CLIENT_NAMES = Object.keys(MCP_CLIENTS);
function isValidClient(client) {
  return CLIENT_NAMES.includes(client);
}
function getClientConfig(client) {
  return MCP_CLIENTS[client];
}
function generateMcpConfig(clientConfig) {
  const serverConfig = {
    command: "npx",
    args: ["panda", "mcp"]
  };
  return {
    [clientConfig.configKey]: {
      panda: serverConfig
    }
  };
}

// src/init.ts
async function initMcpConfig(options = {}) {
  const { cwd = process.cwd() } = options;
  let { clients } = options;
  p.intro("Panda MCP Setup");
  if (!clients || clients.length === 0) {
    const selected = await p.multiselect({
      message: "Select AI clients to configure:",
      options: CLIENT_NAMES.map((client) => ({
        value: client,
        label: MCP_CLIENTS[client].label
      })),
      required: true
    });
    if (p.isCancel(selected)) {
      p.cancel("Setup cancelled.");
      process.exit(0);
    }
    clients = selected;
  }
  const validClients = clients.filter((client) => {
    if (!isValidClient(client)) {
      logger2.warn("mcp:init", `Unknown client: ${client}`);
      return false;
    }
    return true;
  });
  if (validClients.length === 0) {
    p.cancel("No valid clients selected.");
    process.exit(1);
  }
  const results = [];
  for (const client of validClients) {
    const clientConfig = getClientConfig(client);
    const configPath = resolve2(cwd, clientConfig.configPath);
    const configDir = dirname(configPath);
    if (!existsSync(configDir)) {
      mkdirSync(configDir, { recursive: true });
    }
    const newConfig = generateMcpConfig(clientConfig);
    let finalConfig = newConfig;
    if (existsSync(configPath)) {
      try {
        const existingContent = readFileSync(configPath, "utf-8");
        const existingConfig = JSON.parse(existingContent);
        finalConfig = {
          ...existingConfig,
          [clientConfig.configKey]: {
            ...existingConfig[clientConfig.configKey],
            ...newConfig[clientConfig.configKey]
          }
        };
      } catch {
      }
    }
    writeFileSync(configPath, JSON.stringify(finalConfig, null, 2));
    results.push({
      client,
      path: clientConfig.configPath,
      created: true
    });
  }
  p.note(results.map((r) => `${r.client}: ${r.path}`).join("\n"), "Created MCP configurations");
  p.outro("MCP setup complete! Your AI assistants can now use Panda CSS tools.");
  return results;
}
export {
  MCP_CLIENTS,
  createMcpServer,
  initMcpConfig,
  startMcpServer
};
