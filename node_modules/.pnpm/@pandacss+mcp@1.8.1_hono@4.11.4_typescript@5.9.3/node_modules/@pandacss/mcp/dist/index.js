"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  MCP_CLIENTS: () => MCP_CLIENTS,
  createMcpServer: () => createMcpServer,
  initMcpConfig: () => initMcpConfig,
  startMcpServer: () => startMcpServer
});
module.exports = __toCommonJS(index_exports);

// src/server.ts
var import_mcp = require("@modelcontextprotocol/sdk/server/mcp.js");
var import_stdio = require("@modelcontextprotocol/sdk/server/stdio.js");
var import_logger = require("@pandacss/logger");
var import_node = require("@pandacss/node");
var import_token_dictionary = require("@pandacss/token-dictionary");
var import_path = require("path");
var z = __toESM(require("zod/v4"));
var tokenCategorySchema = z.enum(import_token_dictionary.TOKEN_CATEGORIES).optional().describe("Filter by token category");
var json = (data) => ({
  content: [{ type: "text", text: JSON.stringify(data) }]
});
function createMcpServer(options) {
  const { ctx } = options;
  const server = new import_mcp.McpServer({
    name: "@pandacss/mcp",
    version: "1.0.0"
  });
  const recipeNames = ctx.recipes.keys;
  const patternNames = ctx.patterns.keys;
  const recipeNameSchema = recipeNames.length ? z.enum(recipeNames).optional().describe("Filter by recipe name") : z.string().optional().describe("Filter by recipe name");
  const patternNameSchema = patternNames.length ? z.enum(patternNames).optional().describe("Filter by pattern name") : z.string().optional().describe("Filter by pattern name");
  server.registerTool(
    "get_tokens",
    {
      description: "Get all design tokens with their values, CSS variables, and usage examples",
      inputSchema: { category: tokenCategorySchema }
    },
    async ({ category }) => {
      const spec = ctx.getSpecOfType("tokens");
      const data = category ? spec.data.filter((group) => group.type === category) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_semantic_tokens",
    {
      description: "Get semantic tokens with their conditional values (responsive, color modes)",
      inputSchema: { category: tokenCategorySchema }
    },
    async ({ category }) => {
      const spec = ctx.getSpecOfType("semantic-tokens");
      const data = category ? spec.data.filter((group) => group.type === category) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_recipes",
    {
      description: "Get component recipes with their variants, default values, and usage examples",
      inputSchema: { name: recipeNameSchema }
    },
    async ({ name }) => {
      const spec = ctx.getSpecOfType("recipes");
      const data = name ? spec.data.filter((item) => item.name === name) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_patterns",
    {
      description: "Get layout patterns with their properties and usage examples",
      inputSchema: { name: patternNameSchema }
    },
    async ({ name }) => {
      const spec = ctx.getSpecOfType("patterns");
      const data = name ? spec.data.filter((item) => item.name === name) : spec.data;
      return json({ type: spec.type, data });
    }
  );
  server.registerTool(
    "get_conditions",
    { description: "Get all conditions (breakpoints, pseudo-classes, color modes) and their CSS values" },
    async () => json(ctx.getSpecOfType("conditions"))
  );
  server.registerTool(
    "get_keyframes",
    { description: "Get keyframe animations defined in the theme" },
    async () => json(ctx.getSpecOfType("keyframes"))
  );
  server.registerTool(
    "get_text_styles",
    { description: "Get text style compositions for typography" },
    async () => json(ctx.getSpecOfType("text-styles"))
  );
  server.registerTool(
    "get_layer_styles",
    { description: "Get layer style compositions for visual styling" },
    async () => json(ctx.getSpecOfType("layer-styles"))
  );
  server.registerTool(
    "get_animation_styles",
    { description: "Get animation style compositions" },
    async () => json(ctx.getSpecOfType("animation-styles"))
  );
  server.registerTool(
    "get_color_palette",
    { description: "Get the color palette with all color values" },
    async () => json(ctx.getSpecOfType("color-palette"))
  );
  server.registerTool(
    "get_config",
    { description: "Get the resolved Panda CSS configuration including paths, JSX settings, and output options" },
    async () => json(ctx.config)
  );
  server.registerTool(
    "get_usage_report",
    {
      description: "Get a usage report of design tokens and recipes across the codebase. Shows which tokens/recipes are used, unused, or missing. Useful for auditing, cleanup, and identifying dead code.",
      inputSchema: {
        scope: z.enum(["all", "token", "recipe"]).optional().describe("Analysis scope: token, recipe, or all (default)")
      }
    },
    async ({ scope }) => {
      const result = (0, import_node.analyze)(ctx);
      const includeTokens = !scope || scope === "all" || scope === "token";
      const includeRecipes = !scope || scope === "all" || scope === "recipe";
      const report = {};
      if (includeTokens && !ctx.tokens.isEmpty) {
        const tokenReport = result.getTokenReport();
        report.tokens = tokenReport.report.getSummary();
      }
      if (includeRecipes && !ctx.recipes.isEmpty()) {
        const recipeReport = result.getRecipeReport();
        report.recipes = recipeReport.report;
      }
      return json(report);
    }
  );
  return server;
}
async function startMcpServer(options = {}) {
  const { cwd = process.cwd(), config: configPath, silent = false, transport } = options;
  if (silent) {
    import_logger.logger.level = "silent";
  }
  const resolvedCwd = (0, import_path.resolve)(cwd);
  const resolvedConfigPath = configPath ? (0, import_path.resolve)(configPath) : void 0;
  const ctx = await (0, import_node.loadConfigAndCreateContext)({
    cwd: resolvedCwd,
    configPath: resolvedConfigPath
  });
  const server = createMcpServer({ ctx });
  const serverTransport = transport ?? new import_stdio.StdioServerTransport();
  await server.connect(serverTransport);
  console.error("Panda CSS MCP server started");
  console.error(`Working directory: ${resolvedCwd}`);
  if (resolvedConfigPath) {
    console.error(`Config path: ${resolvedConfigPath}`);
  }
  return server;
}

// src/init.ts
var p = __toESM(require("@clack/prompts"));
var import_logger2 = require("@pandacss/logger");
var import_fs = require("fs");
var import_path2 = require("path");

// src/clients.ts
var MCP_CLIENTS = {
  claude: {
    name: "claude",
    label: "Claude (.mcp.json)",
    configPath: ".mcp.json",
    configKey: "mcpServers"
  },
  cursor: {
    name: "cursor",
    label: "Cursor (.cursor/mcp.json)",
    configPath: ".cursor/mcp.json",
    configKey: "mcpServers"
  },
  vscode: {
    name: "vscode",
    label: "VS Code (.vscode/mcp.json)",
    configPath: ".vscode/mcp.json",
    configKey: "servers"
  },
  windsurf: {
    name: "windsurf",
    label: "Windsurf (.windsurf/mcp.json)",
    configPath: ".windsurf/mcp.json",
    configKey: "mcpServers"
  },
  codex: {
    name: "codex",
    label: "Codex (.codex/mcp.json)",
    configPath: ".codex/mcp.json",
    configKey: "mcpServers"
  }
};
var CLIENT_NAMES = Object.keys(MCP_CLIENTS);
function isValidClient(client) {
  return CLIENT_NAMES.includes(client);
}
function getClientConfig(client) {
  return MCP_CLIENTS[client];
}
function generateMcpConfig(clientConfig) {
  const serverConfig = {
    command: "npx",
    args: ["panda", "mcp"]
  };
  return {
    [clientConfig.configKey]: {
      panda: serverConfig
    }
  };
}

// src/init.ts
async function initMcpConfig(options = {}) {
  const { cwd = process.cwd() } = options;
  let { clients } = options;
  p.intro("Panda MCP Setup");
  if (!clients || clients.length === 0) {
    const selected = await p.multiselect({
      message: "Select AI clients to configure:",
      options: CLIENT_NAMES.map((client) => ({
        value: client,
        label: MCP_CLIENTS[client].label
      })),
      required: true
    });
    if (p.isCancel(selected)) {
      p.cancel("Setup cancelled.");
      process.exit(0);
    }
    clients = selected;
  }
  const validClients = clients.filter((client) => {
    if (!isValidClient(client)) {
      import_logger2.logger.warn("mcp:init", `Unknown client: ${client}`);
      return false;
    }
    return true;
  });
  if (validClients.length === 0) {
    p.cancel("No valid clients selected.");
    process.exit(1);
  }
  const results = [];
  for (const client of validClients) {
    const clientConfig = getClientConfig(client);
    const configPath = (0, import_path2.resolve)(cwd, clientConfig.configPath);
    const configDir = (0, import_path2.dirname)(configPath);
    if (!(0, import_fs.existsSync)(configDir)) {
      (0, import_fs.mkdirSync)(configDir, { recursive: true });
    }
    const newConfig = generateMcpConfig(clientConfig);
    let finalConfig = newConfig;
    if ((0, import_fs.existsSync)(configPath)) {
      try {
        const existingContent = (0, import_fs.readFileSync)(configPath, "utf-8");
        const existingConfig = JSON.parse(existingContent);
        finalConfig = {
          ...existingConfig,
          [clientConfig.configKey]: {
            ...existingConfig[clientConfig.configKey],
            ...newConfig[clientConfig.configKey]
          }
        };
      } catch {
      }
    }
    (0, import_fs.writeFileSync)(configPath, JSON.stringify(finalConfig, null, 2));
    results.push({
      client,
      path: clientConfig.configPath,
      created: true
    });
  }
  p.note(results.map((r) => `${r.client}: ${r.path}`).join("\n"), "Created MCP configurations");
  p.outro("MCP setup complete! Your AI assistants can now use Panda CSS tools.");
  return results;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  MCP_CLIENTS,
  createMcpServer,
  initMcpConfig,
  startMcpServer
});
